



# C++语法

## 基础知识

> 学习语言最好的方式就是实践，每当掌握一个新功能时，就要立即将这个功能应用到实践中。

---

### 头文件

- **string是c++语言中string类模板的申明**
- **string.h是标准C提高的字符处理函数集，面向char\*，C语言里面关于字符数组的函数定义的头文件**
- **cstring是c++对c语言中的strcpy之类的函数申明，包含cstring之后，就可以在程序中使用c语言风格的strcpy之类的函数。**

> string：是C++特化的字符容器，内含string类。
>
> string.h：strlen、strcmp、strcpy

```C++
#include <cmath> // 相当于C语言里面的#include <math.h>
#include <cstdio> // 相当于C语言里面的#include <stdio.h>
#include <cctype> // 相当于C语言里面的#include <ctype.h>
#include <cstring> // 相当于C语言里面的#include <string.h>
```

#### 常用函数的头文件

`#include<iostream>`

- max
- abs
- min
- to_string

---

### 类型别名

- 可以给复杂的数据类型起别名

#### typedef

```C++
typedef long long LL;
LL a = 12345678987654321,b=12345678912345678;
```

#### using【√】

```C++
using ll = long long;
ll a = 12345678987654321,b=12345678912345678;
```

------

### ASCII码

- **小写字母比大写字母的ASCII码值大32**

- - **0 ~ 9： 48~57**

  - **A ~ Z：65~90**

  - **a ~ z：97~122**

  - **\0：代表空字符，其ASCII码为0，注意\0不是空格**

  - **控制响铃的控制字符：7**

---

### 常量

#### 字符常量

- ###### 必须用单引号标注起来

```C++
char c1='z',c2='j',c3='117'; //字符就是按照ASCII码存储的 
printf("%c%c%c",c1,c2,c3);  //zju
```

---

#### 字符串常量

> ​	字符串常量是**由若干字符组成的串**，在C语言中没有单独一种基本数据类型可以存储（C++中有string类型），只能使用字符数组的方式。字符常量就是单个使用单引号标记的字符，那么字符串常量则是由双引号标记的字符集。
>
> C：str[]
>
> C++：string

```C++
char str[10];
//scanf("%s",str);	// 输入不需要加&
char str[25] = "I wish I can get full marks in PAT advanced level."
//求长度
int len = strlen(str);
```

```C++
//getline(cin, s);  //输入
string s = "I wish I can get full marks in PAT advanced level."
//求长度
int len = s.size();		
//或者
int len = s.length();
```

#### 预定义常量

- #define  ——  C
- const  ——  C++

##### 符号常量 - 宏定义

```C++
// 格式：#define 标识符 常量  (末尾不加分号)
#include<math.h>
#define PI acos(-1)
#define max(x,y) (x>=(y))?x:(y)
```

- **可以快速定义简单函数**

```C++
#include<stdio.h>
#define ADD(a,b) ((a)+(b))  
// 记得加上括号，因为“宏定义是直接将对应的部分替换”，可能会出现异常；末尾不要加分号 
int main(){
	int n1=3,n2=5;
	printf("%d",ADD(n1,n2));
	return 0;
}
```

##### 使用const （√ ）

```C++
// 格式：const 数据类型 变量名 = 常量；（末尾加分号）
const double pi = 3.1415926;
```

---



### 变量

- 变量必须先定义，才可以使用

- 不能重名

  ```c++
  #include <iostream>
  using namespace std;
  int main(){
      int a = 5;
      int b, c = a, d = 10 / 2;
      return 0;
  }
  ```

#### 浮点型

- **碰到浮点型的数据都应该用double来存储，而不是float**

```C++
  double db;
  输入：scanf("%lf",&db); 
  输出：printf("%f",db);
```

---

#### 布尔型

- **true和false在存储时分别为1和0，因此如果使用%d输出bool型变量，则true和false会输出1和0**

---

### 输入输出

#### 整数的输入输出

```C++
#include <iostream>
using namespace std;
int main() {
	int a, b;
	cin >> a >> b;
	cout << a + b << endl;
	return 0;
}
```

#### 字符串的输入输出

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
	string str;
	cin >> str;
	cout << str;
	return 0;
}
```

#### 不同类型变量的输入输出

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
	int a, b;
	string str;
	cin >> a;
	cin >> b >> str;
	cout << str << " !!! " << a + b << endl;
	return 0;
}
```

### 表达式

- 整数的加减乘除四则运算

```C++
#include <iostream>
#include <string>
using namespace std;
int main(){
    int a = 6 + 3 * 4 / 2 - 2;
    cout << a << endl;
    int b = a * 10 + 5 / 2;
    cout << b << endl;
    cout << 23 * 56 - 78 / 3 << endl;
    return 0;
}
```

- 浮点数（小数）的运算：

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
	float x = 1.5, y = 3.2;
	cout << x * y << ' ' << x + y << endl;
	cout << x - y << ' ' << x / y << endl;
	return 0;
}
```

- 整型变量的自增、自减：

```C++
#include <iostream>
#include <string>
using namespace std;
int main(){
    int a = 1;
    int b = a ++ ;
    cout << a << ' ' << b << endl;
    int c = ++ a;
    cout << a << ' ' << c << endl;
    return 0;
}
```

- 变量的类型转换：

```C++
#include <iostream>
#include <string>
using namespace std;
int main(){
    float x = 123.12;
    int y = (int)x;
    cout << x << ' ' << y << endl;
    return 0;
}
```

### 顺序语句

```C++
// 输出第二个整数：
#include <iostream>
#include <string>
using namespace std;
int main(){
    int a, b, c;
    cin >> a >> b >> c;
    cout << b << endl;
    return 0;
}
```

```C++
//带余除法
#include <iostream>
#include <string>
using namespace std;
int main(){
    int a, b;
    cin >> a >> b;
    int c = a / b, d = a % b;
    cout << c << ' ' << d << endl;
    return 0;
}
```

```C++
//求反三位数：
#include <iostream>
#include <string>
using namespace std;
int main(){
    int n;
    cin >> n;
    
    int a = n % 10;
    n = n / 10;
    int b = n % 10;
    n = n / 10;
    int c = n;
   
    cout << a << b << c << endl;
    return 0;
}
```

```C++
//交换两个整数
#include <iostream>
#include <string>
using namespace std;
int main(){
    int a = 3, b = 4;
    int t = a;
    a = b;
    b = t;
    cout << a << ' ' << b << endl;
    return 0;
}
```

## print语句与判断结构

### printf输出格式

注意：使用printf时最好添加头文件 #include <cstdio>。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	printf("Hello World!");
	return 0;
}
```

#### Int、float、double、char等类型的输出格式：

- int：%d
- float: %f, 默认保留6位小数
- double: %lf， 默认保留6位小数
- char: %c, 回车也是一个字符，用'\n'表示

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a = 3;
	float b = 3.12345678;
	double c = 3.12345678;
	char d = 'y';

	printf("%d\n", a);
	printf("%f\n", b);
	printf("%lf\n", c);
	printf("%c\n", d);

	return 0;
}
```

#### 所有输出的变量均可包含在一个字符串中

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a = 3;
	float b = 3.12345678;
	double c = 3.12345678;
	char d = 'y';
	printf("int a = %d, float b = %f\ndouble c = %lf, char d = %c\n", a, b, c, d);
	return 0;
}
```


练习：输入一个字符，用这个字符输出一个菱形：

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	char c;
	cin >> c;
	printf("  %c\n", c);
	printf(" %c%c%c\n", c, c, c);
	printf("%c%c%c%c%c\n", c, c, c, c, c);
	printf(" %c%c%c\n", c, c, c);
	printf("  %c\n", c);
	return 0;
}
```


练习：输入一个整数，表示时间，单位是秒。输出一个字符串，用”时:分:秒”的形式表示这个时间。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int t;
	cin >> t;
	int hours = t / 3600;
	int minutes = t % 3600 / 60;
	int seconds = t % 60;
	printf("%d:%d:%d\n", hours, minutes, seconds);
	return 0;
}
```

#### 扩展功能

1. `float`, `double`等输出保留若干位小数时用：`%.4f`, `%.3lf`

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	float b = 3.12345678;
	double c = 3.12345678;
	printf("%.4f\n", b);
	printf("%.3lf\n", c);
	return 0;
}
```

2. 最小数字宽度

-  `%8.3f`, 表示这个浮点数的最小宽度为8，保留3位小数，当宽度不足时在前面补空格。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a = 3;
	float b = 3.12345678;
	double c = 3.12345678;
	printf("%5d\n", a);
	printf("%8.4f\n", b);
	printf("%7.3lf\n", c);
	return 0;
}
```

- `%-8.3f`，表示最小宽度为8，保留3位小数，当宽度不足时在后面补上空格

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a = 3;
	float b = 3.12345678;
	double c = 3.12345678;
	printf("%-5d!\n", a);
	printf("%-8.4f!\n", b);
	printf("%-7.3lf!\n", c);
	return 0;
}
```

- `%08.3f`, 表示最小宽度为8，保留3位小数，当宽度不足时在前面补上0

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a = 3;
	float b = 3.12345678;
	double c = 3.12345678;
	printf("%05d\n", a);
	printf("%08.4f\n", b);
	printf("%07.3lf\n", c);
	return 0;
}
```

### if 语句

#### 基本if-else语句

当条件成立时，执行某些语句；否则执行另一些语句。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a;
	cin >> a;
	if (a > 5) {
		printf("%d is big!\n", a);
		printf("%d + 1 = %d\n", a, a + 1);
	} else {
		printf("%d is small!\n", a);
		printf("%d - 1 = %d\n", a, a - 1);
	}
	return 0;
}
```

else 语句可以省略：

```C++
#include <iostream>
#include <cstdio>
using namespace std; 
int main() {
	int a;
	cin >> a;
	if (a > 5) {
		printf("%d is big!\n", a);
		printf("%d + 1 = %d\n", a, a + 1);
	}
	return 0;

}
```

当只有一条语句时，大括号可以省略：

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a;
	cin >> a;
	if (a > 5)
		printf("%d is big!\n", a);
	else
		printf("%d is small!\n", a);
	return 0;
}
```

练习：输入一个整数，输出这个数的绝对值。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int x;
	cin >> x;
	if (x > 0) cout << x << endl;
	else cout << -x << endl;
	return 0;
}
```

练习：输入两个整数，输出两个数中较大的那个。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a, b;
	cin >> a >> b;
	if (a > b)
		cout << a << endl;
	else
		cout << b << endl;
	return 0;
}
```

if-else语句内部也可以是if-else语句。

练习：输入三个整数，输出三个数中最大的那个。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a, b, c;
	cin >> a >> b >> c;
	if (a > b) {
		if (a > c) cout << a << endl;
		else cout << c << endl;
	} else {
		if (b > c) cout << b << endl;
		else cout << c << endl;
	}
	return 0;
}
```

#### 常用比较运算符

- 大于 >
- 小于 <
- 大于等于 >=
- 小于等于 <=
- 等于 ==
- 不等于 !=

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a, b;
	cin >> a >> b;
	if (a > b) printf("%d > %d\n", a, b);
	if (a >= b) printf("%d >= %d\n", a, b);
	if (a < b) printf("%d < %d\n", a, b);
	if (a <= b) printf("%d <= %d\n", a, b);
	if (a == b) printf("%d == %d\n", a, b);
	if (a != b) printf("%d != %d\n", a, b);
	return 0;
}
```

#### if-else连写

>输入一个0到100之间的分数，
如果大于等于85，输出A；
如果大于等于70并且小于85，输出B；
如果大于等于60并且小于70，输出C；
如果小于60，输出 D；

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int s;
	cin >> s;
	if (s >= 85) {
		printf("A");
	} else if (s >= 70) {
		printf("B");
	} else if (s >= 60) {
		printf("C");
	} else {
		printf("D");
	}
	return 0;
}
```


练习：

1.简单计算器输入两个数，以及一个运算符+, -, *, /，输出这两个数运算后的结果。当运算符是/，且除数是0时，输出Divided by zero!; 当输入的字符不是+, -, *, /时，输出Invalid operator!。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a, b;
	char c;
	cin >> a >> b >> c;
	if (c == '+') cout << a + b << endl;
	else if (c == '-') cout << a - b << endl;
	else if (c == '*') cout << a * b << endl;
	else if (c == '/') {
		if (b != 0) {
			cout << a / b << endl;
		} else {
			cout << "Divided by zero!" << endl;
		}
	} else {
		cout << "Invalid operator!" << endl;
	}
	return 0;
}
```

2.判断闰年。闰年有两种情况：
(1) 能被100整除时，必须能被400整除；
(2) 不能被100整除时，被4整除即可。
输入一个年份，如果是闰年输出yes，否则输出no。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int year;
	cin >> year;
	if (year % 100 == 0) {
		if (year % 400 == 0) cout << "yes" << endl;
		else cout << "no" << endl;
	} else {
		if (year % 4 == 0) cout << "yes" << endl;
		else cout << "no" << endl;
	}
	return 0;
}
```

### 条件表达式

- 与 `&&`
- 或 `||`
- 非 `!`

例题：输入三个数，输出三个数中的最大值。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int a, b, c;
	cin >> a >> b >> c;
	if (a >= b && a >= c) cout << a << endl;
	else if (b >= a && b >= c) cout << b << endl;
	else cout << c << endl;
	return 0;
}
```

练习：用一条if语句，判断闰年。

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	int year;
	cin >> year;
	if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0)
		cout << "yes" << endl;
	else
		cout << "no" << endl;
	return 0;
}
```

## 循环结构

学习循环语句只需要抓住一点——代码执行顺序！

### while循环

可以简单理解为循环版的if语句。if语句是判断一次，如果条件成立，则执行后面的语句；while是每次判断，如果成立，则执行循环体中的语句，否则停止。

```C++
#include <iostream>
using namespace std;
int main() {
	int i = 0;
	while (i < 10) {
		cout << i << endl;
		i ++ ;
	}
	return 0;
}
```

练习：求1~100中所有数的立方和。

```C++
#include <iostream>
using namespace std;
int main() {
	int i = 1, sum = 0;
	while (i <= 100) {
		sum += i * i * i;
		i ++ ;
	}
	cout << sum << endl;
	return 0;
}
```

练习：求斐波那契数列的第n项。f(1) = 1, f(2) = 1, f(3) = 2, f(n) = f(n-1) + f(n-2)。

```C++
#include <iostream>
using namespace std;
int main() {
	int n;
	cin >> n;
	int a = 1, b = 1, i = 1;
	while (i < n) {
		int c = a + b;
		a = b;
		b = c;
		i ++ ;
	}
	cout << a << endl;
	return 0;
}
```

死循环：循环永久执行，无法结束。我们要避免写出死循环。

```C++
#include <iostream>
using namespace std;
int main() {
	int x = 1;
	while (x == 1) puts("!");
	return 0;

}
```

### do while循环

- `do while`循环不常用。
  `do while`语句与`while`语句非常相似。唯一的区别是，`do while`语句限制性循环体后检查条件。不管条件的值如何，我们都要至少执行一次循环。

```C++
#include <iostream>
using namespace std;
int main() {
	int x = 1;
	while (x < 1) {
		cout << "x!" << endl;
		x ++ ;
	}
	int y = 1;
	do {
		cout << "y!" << endl;
	} while (y < 1);
	return 0;
}
```

### for循环

基本思想：把控制循环次数的变量从循环体中剥离。

```C++
for (init - statement : condition : expression) {
	statement
}
```

`init-statement`可以是声明语句、表达式、空语句，一般用来初始化循环变量；
`condition`是条件表达式，和`while`中的条件表达式作用一样；可以为空，空语句表示`true`；
`expression`一般负责修改循环变量，可以为空。

```C++
#include <iostream>
using namespace std;
int main() {
	for (int i = 0; i < 10; i++ ) {
		cout << i << endl;
	}
	return 0;
}
```

`init-statement`可以定义多个变量，`expression`也可以修改多个变量。

例如求 `1 * 10 + 2 * 9 + 3 * 8 + 4 * 7 + 5 * 6`：

```C++
#include <iostream>
using namespace std;
int main() {
	int sum = 0;
	for (int i = 1, j = 10; i < j; i ++, j -- ) {
		sum += i * j;
	}
	cout << sum << endl;
	return 0;
}
```

### 跳转语句

#### break

可以提前从循环中退出，一般与if语句搭配。
例题：判断一个大于1的数是否是质数：

```C++
#include <iostream>
using namespace std;
int main() {
	int n;
	cin >> n;
	bool is_prime = true;
	for (int i = 2; i < n; i ++ )
		if (n % i == 0) {
			is_prime = false;
			break;
		}
	if (is_prime) cout << "yes" << endl;
	else cout << "no" << endl;
	return 0;
}
```

#### continue

可以直接跳到当前循环体的结尾。作用与if语句类似。
例题：求1~100中所有偶数的和。

```C++
#include <iostream>
using namespace std;
int main() {
	int sum = 0;
	for (int i = 1; i <= 100; i ++ ) {
		if (i % 2 == 1) continue;
		sum += i;
	}
	cout << sum << endl;
	return 0;
}
```

### 多层循环

```C++
#include <iostream>
using namespace std;
int main() {
	for (int i = 0, k = 1; i < 10; i ++ ) {
		for (int j = 0; j < 10; j ++, k ++ ) {
			cout << k << ' ';
		}
		cout << endl;
	}
	return 0;
}
```

练习：打印1~100中的所有质数

```C++
#include <iostream>
using namespace std;
int main() {
	for (int i = 2; i <= 100; i ++ ) {
		bool is_prime = true;
		for (int j = 2; j < i; j ++ ) {
			if (i % j == 0) {
				is_prime = false;
				break;
			}
		}
		if (is_prime) cout << i << endl;
	}
	return 0;
}
```

练习：输入一个n，打印n阶菱形。n是奇数。

n = 9时的结果：

```C++
    *    
   ***   
  *****  
 ******* 
*********
 ******* 
  *****  
   ***   
    *   
```

```C++
#include <iostream>
using namespace std;
int main() {
	int n;
	cin >> n;
	int cx = n / 2, cy = n / 2;
	for (int i = 0; i < n; i ++ ) {
		for (int j = 0; j < n; j ++ )
			if (abs(i - cx) + abs(j - cy) <= n / 2)
				cout << '*';
			else cout << ' ';
		cout << endl;
	}
	return 0;
}
```

## 数组

> 程序 = 逻辑 + 数据，数组是存储数据的强而有力的手段。

### 一维数组

#### 数组的定义

数组的定义方式和变量类似。

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int a[10], b[10];
	float f[33];
	double d[123];
	char c[21];
	return 0;
}
```



#### 数组的初始化

在main函数内部，未初始化的数组中的元素是随机的。

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int a[3] = {0, 1, 2};           // 含有3个元素的数组，元素分别是0, 1, 2
	int b[] = {0, 1, 1};            // 维度是3的数组
	int c[5] = {0, 1, 2};           // 等价于c[] = {0, 1, 2, 0, 0}
	char d[3] = {'a', 'b', 'c'};    // 字符数组的初始化
	return 0;
}
```



#### 访问数组元素

通过下标访问数组。

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int a[3] = {0, 1, 2};  // 数组下标从0开始
	cout << a[0] << ' ' << a[1] << ' ' << a[2] << endl;
	a[0] = 5;
	cout << a[0] << endl;
	return 0;
}
```

练习题1： 使用数组实现求斐波那契数列的第 NN 项。

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int n;
	int f[100];
	cin >> n; 
	f[0] = 0, f[1] = 1;
	for (int i = 2; i <= n; i ++ ) f[i] = f[i - 1] + f[i - 2];
	cout << f[n] << endl;
	return 0;

}
```

练习题2：输入一个 nn，再输入 nn 个整数。将这 nn 个整数逆序输出。

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int n;
	int a[100];
	cin >> n;
	for (int i = 0; i < n; i ++ ) cin >> a[i];
	for (int i = n - 1; i >= 0; i -- ) cout << a[i] << ' ';
	cout << endl;
	return 0;
}
```

练习题3：输入一个 nn，再输入 nn 个整数。将这个数组顺时针旋转 k(k≤n)k(k≤n) 次，最后将结果输出。
旋转一次是指：将最左边的数放到最右边。

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int n, k;
	int a[100];
	cin >> n >> k;
	for (int i = 0; i < n; i ++ ) cin >> a[i];
	reverse(a, a + k);
	reverse(a + k, a + n);
	reverse(a, a + n);
	for (int i = 0; i < n; i ++ ) cout << a[i] << ' ';
	cout << endl;
	return 0;
}
```

练习题4：输入 nn 个数，将这 nn 个数按从小到大的顺序输出。

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int n;
	int a[100];
	cin >> n;
	for (int i = 0; i < n; i ++ ) cin >> a[i];
	for (int i = 0; i < n; i ++ )
		for (int j = i + 1; j < n; j ++ )
			if (a[i] > a[j])
				swap(a[i], a[j]);

	for (int i = 0; i < n; i ++ ) cout << a[i] << ' ';
	cout << endl;
	return 0;
}
```

练习题5：计算 22 的 NN 次方。N≤10000N≤10000

```C++
#include <iostream>
#include <algorithm>
using namespace std; 
int main() {
	int a[10000], size = 1, n;
	a[0] = 1;

	cin >> n;
	while (n -- ) {
		int t = 0;
		for (int i = 0; i < size; i ++ ) {
			t += a[i] * 2;
			a[i] = t % 10;
			t /= 10;
		}
		if (t) a[size ++ ] = t;
	}

	for (int i = size - 1; i >= 0; i -- ) cout << a[i];
	cout << endl;
	return 0;
}
```



### 多维数组

多维数组就是数组的数组。

```C++
int a[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组。

int arr[10][20][30] = {0}; // 将所有元素初始化为0
// 大小为10的数组，它的每个元素是含有20个数组的数组
// 这些数组的元素是含有30个整数的数组
```

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int b[3][4] = {         // 三个元素，每个元素都是大小为4的数组
		{0, 1, 2, 3},       // 第1行的初始值
		{4, 5, 6, 7},       // 第2行的初始值
		{8, 9, 10, 11}      // 第3行的初始值
	};
	return 0;
}
```

练习题：输入一个`n`行 `m`列的矩阵，从左上角开始将其按回字形的顺序顺时针打印出来。

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int n, m;
	int arr[50][50];

	cin >> n >> m;
	for (int i = 0; i < n; i ++ )
		for (int j = 0; j < m; j ++ )
			cin >> arr[i][j];

	bool st[50][50] = {false};
	int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
	int d = 1, x = 0, y = 0;
	for (int i = 0; i < n * m; i ++ ) {
		int a = x + dx[d], b = y + dy[d];
		if (a < 0 || a >= n || b < 0 || b >= m || st[a][b]) {
			d = (d + 1) % 4;
			a = x + dx[d], b = y + dy[d];
		}
		cout << arr[x][y] << ' ';
		st[x][y] = true;
		x = a, y = b;
	}
	cout << endl;
	return 0;
}
```

## 字符串

### 字符与整数的联系——ASCII码

每个常用字符都对应一个-128 ~ 127的数字，二者之间可以相互转化。注意：目前负数没有与之对应的字符。

```C++
#include <iostream>
using namespace std;
int main() {
	char c = 'a';
	cout << (int)c << endl;
	int a = 66;
	cout << (char)a << endl;
	return 0;
}
```

常用ASCII值：'A'- 'Z'是65 ~ 90，'a' - 'z'是97 - 122，0 - 9是 48 - 57。
字符可以参与运算，运算时会将其当做整数：

```C++
#include <iostream>
using namespace std;
int main() {
	int a = 'B' - 'A';
	int b = 'A' * 'B';
	char c = 'A' + 2;

	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	return 0;
}
```

练习：输入一行字符，统计出其中数字字符的个数，以及字母字符的个数。

```
TBD
```



### 字符数组

字符串就是字符数组加上结束符'\0'。

可以使用字符串来初始化字符数组，但此时要注意，每个字符串结尾会暗含一个'\0'字符，因此字符数组的长度至少要比字符串的长度多 11 ！

```C++
#include <iostream>
using namespace std;
int main() {
	char a1[] = {'C', '+', '+'};            // 列表初始化，没有空字符
	char a2[] = {'C', '+', '+', '\0'};      // 列表初始化，含有显示的空字符
	char a3[] = "C++";                      // 自动添加表示字符串结尾的空字符
	char a4[6] = "Daniel";                  // 错误：没有空间可以存放空字符

	return 0;
}
```

#### 字符数组的输入输出

```C++
#include <iostream>
using namespace std;
int main() {
	char str[100];
	cin >> str;             // 输入字符串时，遇到空格或者回车就会停止
	cout << str << endl;    // 输出字符串时，遇到空格或者回车不会停止，遇到'\0'时停止
	printf("%s\n", str);
	return 0;
}
```

读入一行字符串，包括空格：

```C++
#include <iostream>
using namespace std;
int main() {
	char str[100];
	fgets(str, 100, stdin);  // gets函数在新版C++中被移除了，因为不安全。
	// 可以用fgets代替，但注意fgets不会删除行末的回车字符
	cout << str << endl;
	return 0;
}
```



#### 字符数组的常用操作

下面几个函数需要引入头文件:

`#include <string.h>`

- strlen(str)，求字符串的长度
- strcmp(a, b)，比较两个字符串的大小，a < b返回-1，a == b返回0，a > b返回1。这里的比较方式是字典序！
- strcpy(a, b)，将字符串b复制给从a开始的字符数组。

```C++
#include <iostream>
#include <string.h>
using namespace std; 
int main() {
	char a[100] = "hello world!", b[100];
	cout << strlen(a) << endl;
	strcpy(b, a);
	cout << strcmp(a, b) << endl;
	return 0;
}
```



#### 遍历字符数组中的字符：

```C++
#include <iostream>
#include <string.h>
using namespace std;
int main() {
	char a[100] = "hello world!";
// 注意：下述for循环每次均会执行strlen(a)，运行效率较低，最好将strlen(a)用一个变量存下来
	for (int i = 0; i < strlen(a); i ++ )
		cout << a[i] << endl;
	return 0;
}
```


练习：给定一个只包含小写字母的字符串，请你找到第一个仅出现一次的字符。如果没有，输出no。

练习：把一个字符串中特定的字符全部用给定的字符替换，得到一个新的字符串。

### 标准库类型string

可变长的字符序列，比字符数组更加好用。需要引入头文件：

`#include <string>`

#### 定义和初始化

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
	string s1;              // 默认初始化，s1是一个空字符串
	string s2 = s1;         // s2是s1的副本，注意s2只是与s1的值相同，并不指向同一段地址
	string s3 = "hiya";     // s3是该字符串字面值的副本
	string s4(10, 'c');     // s4的内容是 "cccccccccc"
	return 0;
}
```

#### string上的操作

##### (1) string的读写：

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
	string s1, s2;
	cin >> s1 >> s2;
	cout << s1 << s2 << endl;
	return 0;
}
```

注意：不能用printf直接输出string，需要写成：printf(“%s”, s.c_str());

##### (2) 使用getline读取一整行

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
	string s;
	getline(cin, s);
	cout << s << endl;
	return 0;
}
```

##### (3) string的empty和size操作

注意size是无符号整数，因此 s.size() <= -1一定成立

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
	string s1, s2 = "abc";
	cout << s1.empty() << endl;
	cout << s2.empty() << endl;
	cout << s2.size() << endl;
	return 0;
}
```

##### (4) string的比较

支持 >, <, >=, <=, ==, !=等所有比较操作，按字典序进行比较。

##### (5) 为string对象赋值

```C++
// s1的内容是 cccccccccc；s2是一个空字符串
string s1(10, 'c'), s2; 
// 赋值：用s2的副本替换s1的副本
s1 = s2;                
// 此时s1和s2都是空字符串
```

##### (6) 两个string对象相加

```C++
#include<iostream>
#include<cstring>
using namespace std;
int main() {
	string s1 = "Hello, ", s2 = "World!\n";
	string s3 = s1 + s2;	//Hello, World!
	s1 += s2;				//Hello, World!	
	return 0;
}
```

##### (7) 字面值和string对象相加

做加法运算时，字面值和字符都会被转化成string对象，因此直接相加就是将这些字面值串联起来：

```C++
string s1 = "hello", s2 = "world";      // 在s1和s2中都没有标点符号
string s3 = s1 + ", " + s2 + '\n';
```

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少有一个是string：

```C++
string s4 = s1 + ", ";  // 正确：把一个string对象和有一个字面值相加
string s5 = "hello" + ", "; // 错误：两个运算对象都不是string

string s6 = s1 + ", " + "world";  // 正确，每个加法运算都有一个运算符是string
string s7 = "hello" + ", " + s2;  // 错误：不能把字面值直接相加，运算是从左到右进行的
```



#### 处理string对象中的字符

可以将string对象当成字符数组来处理：

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
	string s = "hello world";
	for (int i = 0; i < s.size(); i ++ )
		cout << s[i] << endl;
	return 0;
}
```


或者使用基于范围的for语句：

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
	string s = "hello world";
	for (char c : s) cout << c << endl;
	for (char& c : s) c = 'a';
	cout << s << endl;
	return 0;
}
```

练习：密码翻译，输入一个只包含小写字母的字符串，将其中的每个字母替换成它的后继字母，如果原字母是'z'，则替换成'a'。

练习：输入两个字符串，验证其中一个串是否为另一个串的子串。

## 函数

### 函数基础

一个典型的函数定义包括以下部分：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。

#### 编写函数

我们来编写一个求阶乘的程序。程序如下所示：

```C++
int fact(int val){
    int ret = 1;
    while (val > 1)
        ret *= val -- ;
    return ret;
}
```

函数名字是fact，它作用于一个整型参数，返回一个整型值。return语句负责结束fact并返回ret的值。

#### 调用函数

```C++
int main(){
    int j = fact(5);
    cout << "5! is " << j << endl;
	return 0;
}
```

函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。

#### 形参和实参

实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，依次类推。形参和实参的类型和个数必须匹配。

```C++
fact("hello");      // 错误：实参类型不正确
fact();             // 错误：实参数量不足
fact(42, 10, 0);    // 错误：实参数量过多
fact(3.14);         // 正确：该实参能转换成int类型，等价于fact(3);
```

形参也可以设置默认值，但所有默认值必须是最后几个。当传入的实参个数少于形参个数时，最后没有被传入值的形参会使用默认值。

#### 函数的形参列表

函数的形参列表可以为空，但是不能省略。

```C++
void f1() {/* …. */}            // 隐式地定义空形参列表
void f2(void) {/* … */}         // 显式地定义空形参列表
形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：

int f3(int v1, v2) {/* … */}        // 错误
int f4(int v1, int v2) {/* … */}    // 正确
```



#### 函数返回类型

大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何值。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或者函数的指针。

#### 局部变量、全局变量与静态变量

局部变量只可以在函数内部使用，全局变量可以在所有函数内使用。当局部变量与全局变量重名时，会优先使用局部变量。

### 参数传递

#### 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。

```C++
#include <iostream>
using namespace std;

int f(int x) {
	x = 5;
}

int main() {
	int x = 10;
	f(x);
	cout << x << endl;
	return 0;
}
```



#### 传引用参数

当函数的形参为引用类型时，对形参的修改会影响实参的值。使用引用的作用：避免拷贝、让函数返回额外信息。

```C++
#include <iostream>
using namespace std;

int f(int &x) {
	x = 5;
}

int main() {
	int x = 10;
	f(x);
	cout << x << endl;
	return 0;
}
```



#### 数组形参

在函数中对数组中的值的修改，会影响函数外面的数组。

一维数组形参的写法：

```C++
// 尽管形式不同，但这三个print函数是等价的
void print(int *a) {/* … */}
void print(int a[]) {/* … */}
void print(int a[10]) {/* … */}
```

```C++
#include <iostream>
using namespace std;
void print(int a[]) {
	for (int i = 0; i < 10; i ++ )
		cout << a[i] << endl;
}

int main() {
	int a[10];
	for (int i = 0; i < 10; i ++ )
		a[i] = i;
	print(a);
	return 0;
}
```

多维数组形参的写法：

```C++
// 多维数组中，除了第一维之外，其余维度的大小必须指定
void print(int (*a)[10]) {/* … */}
void print(int a[][10]) {/* … */}
```

```C++
#include <iostream>
using namespace std;
void print(int a[][10]) {
	for (int i = 0; i < 10; i ++ ) {
		for (int j = 0; j < 10; j ++ )
			cout << a[i][j] << ' ';
		cout << endl;
	}
}

int main() {
	int a[10][10];
	for (int i = 0; i < 10; i ++ )
		for (int j = 0; j < 10; j ++ )
			a[i][j] = j;
	print(a);
	return 0;
}
```



### 返回类型和return语句

return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。return语句有两种形式：

```C++
return;
return expression;
```

#### 无返回值函数

没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。

通常情况下，void函数如果想在它的中间位置提前退出，可以使用return语句。return的这种用法有点类似于我们用break语句退出循环。

```C++
void swap(int &v1, int &v2){
    // 如果两个值相等，则不需要交换，直接退出
    if (v1 == v2)
        return;
    // 如果程序执行到了这里，说明还需要继续完成某些功能

	int tmp = v2;
	v2 = v1;
	v1 = tmp;
	// 此处无须显示的return语句
}
```



#### 有返回值的函数

只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换函数的返回类型。

```C++
#include <iostream>
using namespace std;
int max(int x, int y) {
	if (x > y) return x;
	return y;
}

int main() {
	int x, y;
	cin >> x >> y;
	cout << max(x, y) << endl;
	return 0;

}
```


### 函数递归

在一个函数内部，也可以调用函数本身。

```C++
#include <iostream>
using namespace std;
int fact(int n) {
	if (n <= 1) return 1;
	return n * fact(n - 1);
}

int main() {
	int n;
	cin >> n;
	cout << fact(n) << endl;
	return 0;
}
```

## 类与结构体

### 类的定义

```C++
class Person {
	private:
		int age, height;
		double money;
		string books[100];

	public:
		string name;

		void say() {
			cout << "I'm " << name << endl;
		}

		int get_age() {
			return age;
		}

		void add_money(double x) {
			money += x;
		}
};

```

类中的变量和函数被统一称为类的成员变量。

private后面的内容是私有成员变量，在类的外部不能访问；public后面的内容是公有成员变量，在类的外部可以访问。

### 类的使用

```C++
#include <iostream>
using namespace std;
const int N = 1000010;
class Person {
	private:
		int age, height;
		double money;
		string books[100];

	public:
		string name;

		void say() {
			cout << "I'm " << name << endl;
		}

		int set_age(int a) {
			age = a;
		}

		int get_age() {
			return age;
		}

		void add_money(double x) {
			money += x;
		}
} person_a, person_b, persons[100];

int main() {
	Person c;

	c.name = "yxc";      // 正确！访问公有变量
	c.age = 18;          // 错误！访问私有变量
	c.set_age(18);       // 正确！set_age()是共有成员变量
	c.add_money(100);

	c.say();
	cout << c.get_age() << endl;

	return 0;
}
```

结构体和类的作用是一样的。不同点在于类默认是`private`，结构体默认是`public`。

```C++
struct Person {
	private:
		int age, height;
		double money;
		string books[100];

	public:
		string name;

		void say() {
			cout << "I'm " << name << endl;
		}

		int set_age(int a) {
			age = a;
		}

		int get_age() {
			return age;
		}

		void add_money(double x) {
			money += x;
		}
} person_a, person_b, persons[100];
```

## 指针与引用

指针指向存放变量的值的地址。因此我们可以通过指针来修改变量的值。

```C++
#include <iostream>
using namespace std;
int main() {
	int a = 10;
	int *p = &a;
	*p += 5;
	cout << a << endl;
	return 0;
}
```

数组名是一种特殊的指针。指针可以做运算：

```C++
#include <iostream>
using namespace std;
int main() {
	int a[5] = {1, 2, 3, 4, 5};
	for (int i = 0; i < 5; i ++ )
		cout << *(a + i) << endl;
	return 0;
}
```

引用和指针类似，相当于给变量起了个别名。

```C++
#include <iostream>
using namespace std;
int main() {
	int a = 10;
	int &p = a;
	p += 5;
	cout << a << endl;
	return 0;
}
```

### 链表

```C++
#include <iostream>
using namespace std;
struct Node {
	int val;
	Node* next;
} *head;

int main() {
	for (int i = 1; i <= 5; i ++ ) {
		Node* p = new Node();
		p->val = i;
		p->next = head;
		head = p;
	}
	for (Node* p = head; p; p = p->next)
		cout << p->val << ' ';
	cout << endl;
	return 0;
}
```

## STL

### `<vector>`

`vector`是变长数组，支持随机访问，不支持在任意位置 `O(1)`插入。为了保证效率，元素的增删一般应该在末尾进行。

#### 声明

```C++
#include <vector>   // 头文件
vector<int> a;      // 相当于一个长度动态变化的int数组
vector<int> b[233]; // 相当于第一维长233，第二位长度动态变化的int数组
struct rec{…};
vector<rec> c;      // 自定义的结构体类型也可以保存在vector中
```

#### size/empty

`size`函数返回`vector`的实际长度（包含的元素个数），`empty`函数返回一个`bool`类型，表明`vector`是否为空。二者的时间复杂度都是 `O(1)`。

**所有的STL容器都支持这两个方法，含义也相同，之后我们就不再重复给出。**

#### clear

`clear`函数把`vector`清空。

#### 迭代器

迭代器就像STL容器的“指针”，可以用星号*操作符解除引用。

一个保存`int`的`vector`的迭代器声明方法为：

```C++
vector<int>::iterator it;
```

`vector`的迭代器是“随机访问迭代器”，可以把`vector`的迭代器与一个整数相加减，其行为和指针的移动类似。可以把`vector`的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。

#### begin/end

`begin`函数返回指向`vector`中第一个元素的迭代器。例如a是一个非空的`vector`，则`*a.begin()`与`a[0]`的作用相同。

所有的容器都可以视作一个“前闭后开”的结构，`end`函数返回`vector`的尾部，即第`n`个元素再往后的“边界”。`*a.end()`与`a[n]`都是越界访问，其中`n = a.size()`。

下面两份代码都遍历了`vector<int> a`，并输出它的所有元素。

```C++
for (int i = 0; i < a.size(); i ++)
    cout << a[i] << endl;

for (vector<int>::iterator it = a.begin(); it != a.end(); it ++)
    cout << *it << endl;
```

#### front/back

`front`函数返回`vector`的第一个元素，等价于`*a.begin()`和`a[0]`。
`back`函数返回`vector`的最后一个元素，等价于`*--a.end()`和`a[a.size() – 1]`。

#### push_back()和pop_back()

`a.push_back(x)`把元素`x`插入到`vector a`的尾部。
`b.pop_back()`删除`vector a`的最后一个元素。

### `<queue>`

头文件`queue`主要包括循环队列`queue`和优先队列`priority_queue`两个容器。

#### 声明

```C++
queue<int> q;
struct rec{…}; queue<rec> q;                        //结构体rec中必须定义小于号
priority_queue<int> q;                              // 大根堆
priority_queue<int, vector<int>, greater<int>> q;   // 小根堆
priority_queue<pair<int, int>>q;
```

#### 循环队列`queue`

```C++
push    // 从队尾插入
pop     // 从队头弹出
front   // 返回队头元素
back    // 返回队尾元素
```

#### 优先队列`priority_queue`

```C++
push    // 把元素插入堆
pop     // 删除堆顶元素
top     // 查询堆顶元素（最大值）
```



### `<set>`

头文件`set`主要包括`set`和`multiset`两个容器，分别是“有序集合”和“有序多重集合”，即前者的元素不能重复，而后者可以包含若干个相等的元素。`set`和`multiset`的内部实现是一棵红黑树，它们支持的函数基本相同。

#### 声明

```C++
set<int> s;
struct rec{…}; set<rec> s;  // 结构体rec中必须定义小于号
multiset<double> s;
```

#### size/empty/clear

与`vector`类似

#### 迭代器

`set`和`multiset`的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号`*`解除引用，仅支持`++`和`--`两个与算术相关的操作。

设`it`是一个迭代器，例如`set<int>::iterator it;`

若把`it ++`，则`it`会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在`it`下一名的元素。同理，若把`it --`，则`it`将会指向排在“上一个”的元素。

#### begin/end

返回集合的首、尾迭代器，时间复杂度均为 `O(1)`。

`s.begin()`是指向集合中最小元素的迭代器。

`s.end()`是指向集合中最大元素的下一个位置的迭代器。换言之，就像`vector`一样，是一个“前闭后开”的形式。因此`-- s.end()`是指向集合中最大元素的迭代器。

#### insert

`s.insert(x)`把一个元素`x`插入到集合`s`中，时间复杂度为`O(logn)`。

在`set`中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。

#### find

`s.find(x)`在集合`s`中查找等于`x`的元素，并返回指向该元素的迭代器。若不存在，则返回`s.end()`。时间复杂度为 `O(logn)`。

#### lower_bound/upper_bound

这两个函数的用法与`find`类似，但查找的条件略有不同，时间复杂度为`O(logn)`。

`s.lower_bound(x)`查找大于等于`x`的元素中最小的一个，并返回指向该元素的迭代器。

`s.upper_bound(x)`查找大于`x`的元素中最小的一个，并返回指向该元素的迭代器。

#### erase

设it是一个迭代器，`s.erase(it)`从`s`中删除迭代器it指向的元素，时间复杂度为 `O(logn)`。

设x是一个元素，`s.erase(x)`从s中删除所有等于`x`的元素，时间复杂度为 `O(k+logn)`，其中 `k` 是被删除的元素个数。

#### count

`s.count(x)`返回集合`s`中等于`x`的元素个数，时间复杂度为`O(k+logn)`， 其中 `k`为元素`x`的个数。

### `<map>`

`map`容器是一个键值对`key-value`的映射，其内部实现是一棵以`key`为关键码的红黑树。Map的`key`和`value`可以是任意类型，其中`key`必须定义小于号运算符。

#### 声明

```C++
map<key_type, value_type> name;

//例如：
map<long long, bool> vis;
map<string, int> hash;
map<pair<int, int>, vector<int>> test;
```

#### size/empty/clear/begin/end

均与`set`类似。

#### insert/erase

与`set`类似，但其参数均是`pair<key_type, value_type>`。

#### find

`h.find(x)`在变量名为`h`的`map`中查找`key`为`x`的二元组。

#### `[]`操作符

`h[key]`返回`key`映射的`value`的引用，时间复杂度为O(logn)`。

`[]`操作符是`map`最吸引人的地方。我们可以很方便地通过`h[key]`来得到`key`对应的`value`，还可以对`h[key]`进行赋值操作，改变`key`对应的`value`。

### ` <stack>`

头文件`stack`包含栈。声明和前面的容器类似。

```C++
push    // 向栈顶插入
pop     // 弹出栈顶元素
```

### ` <deque>`

双端队列`deque`是一个支持在两端高效插入或删除元素的连续线性存储空间。它就像是`vector`和`queue`的结合。与`vector`相比，`deque`在头部增删元素仅需要 `O(1)`的时间；与`queue`相比，`deque`像数组一样支持随机访问。

```C++
[]              // 随机访问
begin/end       // 返回deque的头/尾迭代器
front/back      // 队头/队尾元素
push_back       // 从队尾入队
push_front      // 从队头入队
pop_back        // 从队尾出队
pop_front       // 从队头出队
clear           // 清空队列
```

## 常见库函数

### 位运算

| 符号 | 运算 |
| ---- | ---- |
| `&`  | 与   |
| `|`  | 或   |
| `~`  | 非   |
| `^`  | 异或 |
| `>>` | 右移 |
| `<<` | 左移 |

- 求`x`的第`k`位数字 `x >> k & 1`
- `lowbit(x) = x & -x`，返回`x`的最后一位`1`

### 翻转`reverse`

翻转一个`vector`：

```C++
reverse(a.begin(), a.end());
```

翻转一个数组，元素存放在下标`1 ~ n`：

```C++
reverse(a + 1, a + n + 1);
```



### 去重`unique`

返回去重（只去掉**相邻**的相同元素）之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。

把一个`vector`去重：

```C++
int m = unique(a.begin(), a.end()) – a.begin();
```

把一个数组去重，元素存放在下标`1 ~ n`：

```C++
int m = unique(a + 1, a + n + 1) – (a + 1);
```



### 随机打乱`random_shuffle`

用法与`reverse`相同。

### 排序`sort`

对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。

把一个`int`数组（元素存放在下标`1 ~ n`）从大到小排序，传入比较函数：

```C++
int a[MAX_SIZE];
bool cmp(int a, int b){
    return a > b;
}
sort(a + 1, a + n + 1, cmp);
```

把自定义的结构体`vector`排序，重载“小于号”运算符：

```C++
struct Rec{
    int id, x, y;
};

vector<Rec> a;
bool operator <(const Rec &a, const Rec &b){
	return a.x < b.x || a.x == b.x && a.y < b.y;
}

sort(a.begin(), a.end());
```



### 二分`lower_bound/upper_bound` 

`lower_bound`的第三个参数传入一个元素`x`，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于`x`的元素的位置的迭代器（指针）。

`upper_bound`的用法和`lower_bound`大致相同，唯一的区别是查找第一个大于x的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。

在有序`int`数组（元素存放在下标`1 ~ n`）中查找大于等于`x`的最小整数的下标：

```C++
int i = lower_bound(a + 1, a + 1 + n, x) - a;
```

在有序`vector<int>`中查找小于等于`x`的最大整数（假设一定存在）：

```C++
int y = *--upper_bound(a.begin(), a.end(), x);
```





# Java语法



## 编写一个简单的Java程序

```java
public static Main{
    public static void main(String[] args){
        System.out.println("Hello World!");
    }
}
```

## 变量

- 变量必须先定义，才可以使用。**不能重名**。

- 变量定义的方式：

  ```java
  public class Main {
      public static void main(String[] args) {
          int a = 5;
          int b, c = a, d = 10 / 2;
      }
  }
  ```

- 内置数据类型：

  | 类型    | 字节数 | 举例           |
  | ------- | ------ | -------------- |
  | byte    | 1      | 123            |
  | short   | 2      | 12345          |
  | int     | 4      | 12345678       |
  | long    | 8      | 1234567891011L |
  | float   | 4      | 2.4f, 1.2F     |
  | double  | 8      | 1.2, 1.3D      |
  | boolean | 1      | true,false     |
  | char    | 2      | 'A'            |

### 常量

- 使用final修饰：

```java
final int N = 110;
```

- 类型转化：
  - 显示转化：int x = (int)'A';
  - 隐式转化：double x = 12, y = 4 * 3.3;

## 运算符

```java
A = 10, B = 20
```

| 运算符 | `描述`                                           | `实例`                                 |
| ------ | ------------------------------------------------ | -------------------------------------- |
| `+`    | 把两个数相加                                     | `A + B` 将得到 30                      |
| `-`    | 从第一个数中减去第二个数                         | `A - B` 将得到 -10                     |
| `*`    | 把两个数相乘                                     | `A * B` 将得到 200                     |
| `/`    | 分子除以分母                                     | `B / A` 将得到 2                       |
| `%`    | 取模运算符，向零整除后的余数，注意余数可能为负数 | `B % A` 将得到 0                       |
| `++`   | 自增运算符                                       | `A++`：先取值后加1；`++A`：先加1后取值 |
| `--`   | 自减运算符                                       | `A--`：先取值后减1；`--A`：先减1后取值 |
| `+=`   | 第一个数加上第二个数                             | `A = A + B` 可以简写为 `A += B`        |
| `-=`   | 第一个数减去第二个数                             | `A = A - B` 可以简写为 `A -= B`        |
| `*=`   | 第一个数乘以第二个数                             | `A = A * B` 可以简写为 `A *= B`        |
| `/=`   | 第一个数除以第二个数                             | `A = A / B` 可以简写为 `A /= B`        |
| `%=`   | 第一个对第二个数取余数                           | `A = A % B` 可以简写为 `A %= B`        |

## 表达式

整数的加减乘除四则运算：

```java
public class Main {
    public static void main(String[] args) {
		int a = 6 + 3 * 4 / 2 - 2;
		System.out.println(a);
	    int b = a * 10 + 5 / 2;
		System.out.println(b);
		System.out.println(23 * 56 - 78 / 3);
	}
}
```

浮点数（小数）的运算：

```java
public class Main {
    public static void main(String[] args) {
		double x = 1.5, y = 3.2;
		System.out.println(x * y);
		System.out.println(x + y);
		System.out.println(x - y);
		System.out.println(x / y);
	}
}
```

整型变量的自增、自减：

```java
public class Main {
    public static void main(String[] args) {
        int a = 1;
        int b = a ++ ;
        System.out.println(a + " " + b);

        int c = ++ a;
        System.out.println(a + " " + c);
    }
}
```

## 输入

- 方式1，效率较低，输入规模较小时使用。

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        String str = sc.next();  // 读入下一个字符串
        int x = sc.nextInt();  // 读入下一个整数
        float y = sc.nextFloat();  // 读入下一个单精度浮点数
        double z = sc.nextDouble();  // 读入下一个双精度浮点数
        String line = sc.nextLine();  // 读入下一行
    }
}
```

- 方式2，效率较高，输入规模较大时使用。注意需要抛异常。

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();
        System.out.println(str);
    }
}
```

## 输出

- 方式1，效率较低，输出规模较小时使用。

```java
public class Main {
    public static void main(String[] args) throws Exception {
        System.out.println(123);  // 输出整数 + 换行
        System.out.println("Hello World");  // 输出字符串 + 换行
        System.out.print(123);  // 输出整数
        System.out.print("yxc\n");  // 输出字符串
        System.out.printf("%04d %.2f\n", 4, 123.456D);  // 格式化输出，float与double都用%f输出
    }
}
```

`System.out.printf()`中不同类型变量的输出格式：

1. int：%d
2. float: %f, 默认保留6位小数
3. double: %f， 默认保留6位小数
4. char: %c, 回车也是一个字符，用'\n'表示
5. String: %s

- 方式2，效率较高，输出规模较大时使用。注意需要抛异常。

```java
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write("Hello World\n");
        bw.flush();  // 需要手动刷新缓冲区
    }
}
```

## 判断语句

### if语句

#### 基本if-else语句

当条件成立时，执行某些语句；否则执行另一些语句。

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();

        if (a > 5) {
            System.out.printf("%d is big!\n", a);
            System.out.printf("%d + 1 = %d\n", a, a + 1);
        } else {
            System.out.printf("%d is small!\n", a);
            System.out.printf("%d - 1 = %d\n", a, a - 1);
        }
    }
}
```



## Others

- java不需要`return 0;`
- python的类型转换是`int('A')`，c++和java是`(int)'A'`



# Python语法

## 常用函数

### Python内建函数

- `format()`：格式化输出函数(在控制输出精度和空格补齐等问题中很好用)

- `round(x)`：四舍五入

- `cmp(x, y)`：比较2个对象，如果 x < y 返回 −1, 如果 x = y 返回 0, 如果x > y返回1 

- `abs(x)/max()/min()`：绝对值/最大值/最小值

- `len()`：返回对象的长度，如列表、字典等

- `range(start=0, stop, step=1])`：返回一个可迭代对象，常用于for循环

- `sum(iterable)`： 求和函数

- `pow(x, y, [z])`：求幂函数x^y^ ，运算完毕可以顺带对z取模；大数取模问题可以直接AC

- `sorted(iterable, key, reverse)`：采用[Timsort](https://en.wikipedia.org/wiki/Timsort)的稳定排序算法，默认升序；该函数太重要了，请多写写代码研究一下它的各个参数

  > sorted 语法：
  >
  > ```python
  > sorted(iterable, cmp=None, key=None, reverse=False)
  > ```
  >
  > 参数说明：
  >
  > - iterable -- 可迭代对象。
  > - cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
  > - key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
  > - reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。

- `isinstance(obj, type)`：判断类型

- `all(iterable) / any(iterable)`：迭代与操作/迭代或操作（0、1、None均等价于False)

- `int(x, base=10))/float()/str()`：转整数(可自定义进制)/转浮点数/转字符串

- `bin()/oct()/hex()`：10进制转二进制(返回0b开头的字符串)/10进制转八进制(返回0开头的字符串)/10进制转十六进制(返回0x开头的字符串)

- `ord()/chr()`：字符转ASCII或ASCII转字符

- `complex(real, imag)`：创建一个复数，不过现在可以直接通过语法糖创建，eg：`1+2j`

- `divmod()`：函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)

- `eval(expression, [globals, locals])`：**执行一个字符串表达式**，并返回表达式的值，在某些字符串解析题中非常好用。

  > 以下是 eval() 方法的语法:
  >
  > ```python
  > eval(expression[, globals[, locals]])
  > ```
  >
  > ### 参数
  >
  > - expression -- 表达式。
  > - globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。
  > - locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。
  >
  > ### 返回值
  >
  > 返回表达式计算结果。
  >
  > ------
  >
  > ## 实例
  >
  > 以下展示了使用 eval() 方法的实例：
  >
  > ```python
  > >>>x = 7
  > >>> eval( '3 * x' )
  > 21
  > >>> eval('pow(2,2)')
  > 4
  > >>> eval('2 + 2')
  > 4
  > >>> n=81
  > >>> eval("n + 4")
  > 85
  > ```
  >
  > 

- `map(function, iterable...)`：映射函数，需要注意的是在Python3中返回一个迭代对象而不再是一个列表

- `filter(function, iterable)`：过滤函数

- `reduce(function, iterable, [initializer])`：累积函数，现在被归类到functools模块

- `zip(iterable, ...)`：将对象中对应的元素打包成一个个元组，常用于并联取值，详见下文的【注意事项】

- `hash(obj)`：返回哈希码，常用于对象比较或将其转化为唯一的索引(不过更推荐使用id()完成该需求)

- `id()`：返回对象的唯一标识符，和`hash()`类似，但更鲁棒更快且可以对list、def等对象求id

- `enumerate()`：将一个可遍历的数据对象组合为一个索引序列，eg:`for i, v in enumerate(list_a):`

**注意事项**

1. 标准输出函数`print(*objects, sep=' ', end='\n')`可以通过设置`seq`标志位来设定间隔字符、设置`end`来设定结尾字符，常用于进行灵活的输出。对列表输出时，也常用`' '.join(result_list)`来快速输出一个串，而不用挨个遍历。

2. 需要注意的是，若从`range()`中取遍历指示器，在Python 3中，在for循环内重复定义迭代变量不影响迭代遍历的值，如：

   ```python
   # (Python 3)该段代码最终输出0 1 2三行，而不是只有一行0
   for i in range(3): # 并不等价于C语言的 for(int i=0;i<3;i++)
   	print(i)
   	i += 10 # 内部遍历不影响作为循环i的值，这跟C语言差异很大，请留心
   ```

3. `map`、`filter`、`reduce`等函数式编程函数很重要，能够让你少敲很多代码，特别是`filter`在筛选题中有高的实用性。

4. 特别的，`float()`可用来构造无限值，如`float('inf')`

5. `yield`关键字也很重要，可用来创建生成器，在数列生成、斐波那契查找等用处很大，可以极大的节省开销。[>举例一则<](https://blog.csdn.net/Shenpibaipao/article/details/105521189)，[>教程指南<](https://www.runoob.com/w3cnote/python-yield-used-analysis.html)。需要注意的是，当迭代器函数执行结束时，将自动抛出`StopIteration`异常，仅在 for 循环里，无需处理`StopIteration`异常，循环会正常结束，否则需要使用`except`关键字捕获。

6. 有些时候`try`、`except Exception as e`、`finally`等语句可以直接避免在函数体里进行空值检定，大大减少敲键盘的时间开销：[>举例一则<](https://blog.nowcoder.net/n/3f94b0d63e384045b6056a03680ac6ff)。

7. 善用`set()`来进行列表去重。

8. `format()`函数能方便你的格式化输出，如小数精度控制问题，请考虑[>进行学习<](https://www.runoob.com/python/att-string-format.html)。

9. `input()`和`raw_input()`的区别在于对于python的两个版本(2/3)表现不一致，python 3请使用前者，接收到的数据默认为`str`。

10. 对于非对象类(如`list`)变量，需要用`global`关键词在函数内使用全局变量。

11. `del`关键词会比`list.pop(index)`拥有更高的效率，属于TLE敏感的操作。

12. `list[::-1]`[语法糖](https://blog.csdn.net/Shenpibaipao/article/details/88651528)可以快速对列表进行倒序，在字符串倒序等问题中有奇效；但`list.reverse()`更高效，属于TLE敏感的操作。(另外需要注意：后者是原地倒序)

13. 在python 3中,`zip()`返回一个可迭代对象，需要手动`list()`以进行其它列表操作。

14. 求均值、中位数、众数的API在`statistics`模块中；求众数可以调用`collections.Counter`来实现。

15. python默认的递归栈很有限，有时候会出现C语言能过而python不能过的情况，请[>参考此处<](https://blog.csdn.net/Shenpibaipao/article/details/105758432)解决这个问题——`maximum recursion depth exceeded in comparison`。

### math

**常量**

- `pi`：圆周率 (`3.141592653589793`)
- `inf`：无限大
- `nan`：非数字(Not A Number)
- `e`：自然数
- `tau`：圆周率的两倍，用于计算弧度和角度的换算。（2π×弧度=360°）

**函数**

- `sqrt(x)`：开平方，eg：`math.sqrt(16) = 4.0`
- `floor(x)`：向下取整，eg：`floor(35.7)=35`
- `ceil(x)`：向上取整，eg：`floor(35.1)= 36`
- `trunc(x)`：直接去除数字的小数部分，作用等同floor
- `gcd(a, b)`：求最大公约数，返回值默认与b同号(b非0时)；任一数为0 00时返回0；
- `pow(x, y)`：求幂(x^y^)，返回浮点数，eg：`math.pow(2,3)=8.0 `
- `log(x, y)`：求对数log~y~x，返回浮点数，eg：`math.log(8,2)= 3.0`
- `radians`：将角度转换为弧度
- `modf(x)`：返回浮点数x xx的小数和整数部分，eg：`modf(32.5)=(0.5,32)`
- `exp(x)`：指数函数e^x^，需要注意的是`math.pow(math.e, x)`精度会更高
- `isnan/isinf/isfinite`：常量检测函数，isfinite当检测数为inf和nan时返回False

**注意事项**

- `math.fabs()`和内建函数中的`abs()`相比，后者支持复数运算。复数的绝对值计算：
  $$
  |a±bj| = \sqrt{a^2+b^2}
  $$

- `divmod(a, b)`与`math.modf(x)`相比，前者返回元组`(a // b, a % b)`，后者拆分小数和整数部分；前者支持复数运算。

- `math.pow()`和内建函数中的`pow()`相比，前者运算为浮点型，后者会保留整形(还可以顺带取模)

- `fractions.gcd()`在Python 3后已被`math.gcd()`取代。

- 最小公倍数：`(a*b) // gcd(a, b)`

### cmath

> 复数运算模块，大部分API与math相同。Python中构建复数的语法示例为：`c = 1 + 1j`，如：

```python
a, b = 1+1j, 1-1j
print(a, b, a+b) # (1+1j) (1-1j) (2+0j)
```

### statistics

> 数据统计模块，补全了中位数、众数、方差的快速实现。同时支持下文的分数模块。

- `mean()`： 数据的算术平均数（“平均数”）
- `harmonic_mean()` ：数据的调和均值
- `median()`：数据的中位数（中间值）
- `median_low()`：数据的低中位数
- `median_high()`：数据的高中位数
- `mode()`：数据的众数
- `pstdev()`：数据的总体标准差
- `pvariance()`：数据的总体方差
- `stdev()`：数据的样本标准差
- `variance()`：数据的样本方差

### fractions

> 分数运算模块，[>参考此处<](https://docs.python.org/zh-cn/3.7/library/fractions.html)

### heapq

> 堆模块，构建小顶堆。构建时直接传入一个列表作为堆结构，调用heapify等函数时会直接改变这个堆列表的内部顺序。

> 小顶堆：根节点的值小于等于其左右节点的值，即`a[k] <= a[2*k+1] and a[k] <= a[2*k+2]`

- `heapify(heap)`：构建/调整一个堆
- `heappop(heap)`：返回最小数
- `heappush(heap, item)`：向堆内压入一个元素
- `heappushpop(heap, item)`：向堆内压入一个元素后返回最小数
- `heapreplace(heap, item)`：删除堆中最小元素并加入一个元素
- `merge(*iterables)`：合并多个有序列表，并返回有序列表的迭代器(即需要手动list())
- `nlargest(n, iterable, key)`：返回最大的n个数的列表
- `nsmallest(n, iterable, key)`：返回最小的n个数的列表

---

技巧：如果要构建大顶堆，对入堆元素取负即可，如：

```python
heap = [1, 2, 3, 4, 5]
heap = [-i for i in heap]
heapify(heap)
m = -heappop(heap) # 注意取负回来
```

另外需要注意，**堆排序是不稳定的**。

### queue

> 队列模块，Queue其实不是很必要，完全可以用List的内建函数替代；比较有用的是其中的PriorityQueue，常用于解图结构相关的问题，如有向图最短距离等。特殊的，还有内建对象deque作为双向队列，本质是封装了collections.deque，此处不做讲解。

> 需要注意是的，queue模块中提供的是同步的类，因此其入列/出列运算速度是比较慢的，远不及list.insert()和list.pop()。

类：

- `Queue(maxsize=0)` ：FIFO 队列。如果maxsize小于等于零，队列尺寸为无限大，下同。
- `LifoQueue(maxsize=0)`： LIFO 队列。
- `PriorityQueue(maxsize=0)`： 优先级队列。

> 优先级队列：二叉堆，本质上就是一个小顶堆/大顶堆。
>

通用API：

- `qsize()`：返回队列大小
- `full()`：队列是否满了
- `put(item, block, timeout)`：以同步的方式入列
- `get(item, block, timeout)`：以同步的方式出列
- `put_nowait(item)`：以非同步的方式入列
- `get_nowait(item)`：以非同步的方式出列

> 优先队列的`item`应该为以下数据格式：`(priority number, data)`

### collections

> 是Python内建的一个集合模块，提供了许多有用的集合类。该模块较为重要，为本文行文流畅考虑，此处仅做简介索引和用方举例。详细了解API可到：[>扩展学习资料<](https://www.liaoxuefeng.com/wiki/1016959663602400/1017681679479008)

常用类：

- `namedtuple`：构建一个可命名的tuple，该类型可用isinstance检定
- `deque`：高效实现插入和删除操作双向列表，比list优异，可直接改造成FIFO队列或栈，API与list基本相同
- `ChainMap`：将多个dict串成一个逻辑上的dict(不修改内存)，往往用于优先级查找
- `Counter`： 计数器，大部分情况下速度会更快，但若只统计个别元素，推荐使用list.count()，接受一个字典或字符串
- `OrderedDict`： 有序字典(按key的值升序排序)，常用来做一个FIFO的有序字典
- `defaultdict`： 访问缺失值时会返回一个默认值的字典而不是抛出KeyError，相当好用，其它行为与dict一致，可以看成是一种更健壮的dict

#### Counter

> 该类由于重载了加、减、del等运算，因此可以直接进行减操作，在**对字符串进行统计**时相当有用。

构造：

- `Counter()`：空构建
- `Counter(st)`：传入一个字符串
- `Counter(dict)`：传入一个字典
- `Counter(key=v, ...)`：传入一些键值对

常用方法：

- `update(Counter)`：
- `most_common(n)`：返回 最多的n个元素的列表

> 例子：
>
> - 构造一个Counter对象
>
> ```python
> """ 构造一个空 Counter 对象 """ 
> # c = Counter()                           # a new, empty counter
> 
> """ 三种构造非空 Counter 对象的方法，返回结果的顺序与输入顺序相同 """
> # 1、a new counter from an iterable
> c = Counter('bccabc')  # Counter({'b': 2, 'c': 3, 'a': 1})                 
> 
> # 2、a new counter from a mapping
> c = Counter({'a': 1, 'b': 2, 'c': 3})  # Counter({'a': 1, 'b': 2, 'c': 3})      
> 
> # 3、a new counter from keyword args
> c = Counter(a=1, b=2, c=3)  # Counter({'a': 1, 'b': 2, 'c': 3})             
> ```
>
> - 执行update方法
>
> ```python
> """ 
> update 后的参数可以是：可迭代对象 或者 映射 
> 操作原理：如果要更新的关键字已存在，则对它的值进行求和；如果不存在，则添加
> """
> # 1、可迭代对象：字符串
> c.update("baaac")
> c
> # Out[118]: Counter({'a': 4, 'b': 3, 'c': 4})
> 
> # 2、映射：字典
> c.update({"d":-2, c['a']:-1})  # 因为 a=4, 所以结果中显示 4: -1
> c
> # Out[128]: Counter({'a': 4, 'b': 3, 'c': 4, 'd': -2, 4: -1})
> 
> # 3、映射：字典的另一种表现形式
> c.update(d=3, a=-1)
> c
> # Out[130]: Counter({'a': 3, 'b': 3, 'c': 4, 'd': 1, 4: -1})
> ```

#### deque

> 当只对首位数据进行操作时，双向队列类比list有着更高的效率。其与`list`相比，用有几乎完全相同的API，只不过`pop()`不允许按index弹出数据，只能弹出队尾数据，并且多了以下API：

- `popleft()`：与`pop()`相对，从尾部弹出数据(没有发现存在比`pop(0, data)`明显的性能优势)
- `appendleft()`：与`append()`相对，向首部添加数据(没有发现存在比`insert(0, data)`明显的性能优势)

> 注意事项：`collections.deque`比`queue.deque`更加强大；后者是对前者的封装，作为模块内建对象存在，而前者这是一个类。后者拥有`dequeue`、`enqueue`等标准队列操作，但个人更推荐使用前者而不是后者。

### 函数式编程/编程风格优化

### functools

> 高阶函数模块，对于数学题或函数式编程风格优化起到重要作用。

主要方法：

- `@lru_cache(maxsize=None, typed=False)`：LRU缓存，在递归和DP中取`maxsize=None`用作记忆法进行剪枝。
- `reduce(function, iterable, [initializer])`：累积函数，常用于列表连续求积

其它方法跟装饰器有关，不一一罗列。

### itertools

> 本模块实现了一系列 iterator，比起手动for循环，会快很多。

无穷迭代器：

- `count(start, [step])`：步进迭代器，生成序列`start, start+step, start+2*step...`
- `cycle(iterable)`：循环迭代器，输入迭代器p，生成序列`p0, p1, ... plast, p0, p1, ...`
- `repeat(obj [,n])`： 重复迭代器，重复无限次或n次，生成序列`obj, obj, obj, ...`

有限迭代器：

- `accumulate(iterable, [func])`：创建一个迭代器，根据func返回累加和或其他二元函数的累加结果。eg：`accumulate([1,2,3,4,5]) --> 1 3 6 10 15`
- `chain`：创建一个迭代器，它首先返回第一个可迭代对象中所有元素，接着返回下一个可迭代对象中所有元素，直到耗尽所有可迭代对象中的元素，eg：`chain('ABC', 'DEF') --> A B C D E F`
- `compress(data, selectors)`：返回 `data` 中经 `selectors` 真值测试为 `True` 的元素，eg：`compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F`
- `dropwhile`：从首次真值测试失败开始，eg：`dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1`
- `takewhile`：直到首次真值测试失败结束，eg：`takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4`
- `filterfalse(predicate, iterable)`：返回`iterable`中`predicate`为`False`的元素，eg：`filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8`
- `groupby(iterable, [key])`：迭代器中相邻的重复元素挑出来放在一起，eg：`for i, v in itertools.groupby('AABBC'): print(i, list(v)) --> A ['A', 'A'] B ['B', 'B'] C ['C']`
- `islice(iterable, start, stop[, step])`：返回从 `iterable` 里选中的元素，eg：`islice('ABCDEFG', 2, None) --> C D E F G`
- `starmap(function, iterable)`：星映射迭代器，eg：`starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000`
- `tee(iterable, n)`：拆分一个迭代器为n个
- `zip_longest`：创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据`fillvalue`填充缺失值，eg：`zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-`

排列组合迭代器：

- `product`：笛卡尔积，eg：`product('ABCD, 2') --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD`

- `permutations`：连续返回由 `iterable` 元素生成长度为 r 的排列，和`combinations`有点类似，即返回组合排列解，eg：`permutations('ABCD, 2') --> AB AC AD BA BC BD CA CB CD DA DB DC`

  > ```python
  > from itertools import permutations  
  > a = "ABC"  
  > p = permutations(a)  
  > 
  > for i in list(p):  
  >     print(i)
  > # ('A', 'B', 'C')
  > # ('A', 'C', 'B')
  > # ('B', 'A', 'C')
  > # ('B', 'C', 'A')
  > # ('C', 'A', 'B')
  > # ('C', 'B', 'A')
  > ```

- `combinations`：返回由输入`iterable`中元素组成长度为r rr的子序列，eg：`combinations('ABCD', 2) --> AB AC AD BC BD CD`

注意事项：

- `accumulate`可通过给定一个`func`来自定义累加过程，例如给定`max`作为累加器，则统计的是至今为止最大的数，在一些题目中相当好用。
- `combinations`本质上就是就是计算组合数，在一些数学题中相当好用，例如`print(len(list(itertools.combinations('ABCD', 2))))`可以直接得到C^4^~2~ = 6 ；permutations则是返回A^2^~2~C^4^~2~。

### 专业导向

> 专业导向的模块除了re以外，一般不怎么用到，只对于某些专业题目，如二进制、文件、时间、加密等。

### datetime

时间模块，可以直接对日期进行加减等操作，在某些日期问题中非常有用。如二月份的日期加减：

print(datetime.date(2019, 2, 28) + datetime.timedelta(days=1))

2019-03-01

1
2
常用类：

date(year, month, day)：日期模型
time(hour, minute, second, microsecond, tzinfo)：时间模型
datetime(...)：日期和时间的结合模型；常用timestamp()可将其转为时间戳
timedelta(days, seconds, microseconds, milliseconds, minutes, hours, weeks)：时间增量，常用total_seconds()可以将其转化为秒。
timezone：时区类

12. calendar
    主要用于构建日历，在诸如打印出某年第某月日历的题目时非常有用，如打印2020年第二个月的日历(注意并不是2月1号到2月29号，而是印刷日历的编号，即为1月27日到3月1日【打开你右下角的windows日历自行查查对】)

c = calendar.Calendar(firstweekday=0) # 0:日历印刷的第一天为星期一
for i in c.itermonthdates(2020, 2):
    print(i)
1
2
3

13. struct
    struct模块来解决bytes和其他二进制数据类型的转换。常用于处理二进制或字符串题。

>简易入门<
>format-characters

14. re
    在这些专业导向的模块中，正则模块则是最重要的模块，能处理大量字符串相关的题目，需要额外学习正则表达式，此处不再赘述，属于必须掌握的模块。请参考>本文档<进行学习。

15. copy
    主要用于处理浅层和深层拷贝，在某些需要自定义数据结构的题目中能方便你进行对象拷贝，属于必须掌握的模块。主要只有两个函数：

copy：返回浅层拷贝。
deepcopy：耗时大，返回深层拷贝对象。

16. os.path
    在一些路径字符串分析题中非常有用，大部分情况下可以用re模块和str替代。

17. string/str
    主要掌握str模块类的以下方法：

strip([chars])：返回原字符串的副本，移除其中的前导和末尾字符；常用于IO
split(sep=None, maxsplit=-1)：返回一个由字符串内单词组成的列表，常用于IO
find(sub, [start], [end])：返回子字符串 sub 在s[start:end]切片内被找到的最小索引
count(sub, [start], [end])：反回子字符串 sub 在 [start, end] 范围内非重叠出现的次数。
center(width, [fillchar])：返回长度为 width 的字符串，原字符串在其正中， 使用指定的 fillchar 填充两边的空位(优先填右)
capitalize()：返回将首字母大写、其余小写的原字符串副本
index(sub, [start], [end])：类似find()，不推荐使用，因为找不到时会触发一个异常
replace(old, new, [count])：替换子串，不过基本都由re.sub()替代该操作
join(iterable)：返回一个由 iterable 中的字符串拼接而成的字符串；常用于IO
lower()/upper()：返回一个副本，将所有字符转为小/大写
lower()/isupper()：判断是否全由小写字母/大写字母组成
isdigit()/isdecimal()/isnumeric()：判断是否全由数字字母组成【区别见下文】
isalnum()/isalpha()：判断是否全由字母和数字组成/判断是否全由字母组成
translate(table)：映射字符串，需要搭配str.maketrans(dict)一起用；eg: print("abc".translate(str.maketrans({"a": "1"})))将会输出1bc
title()：转化为标题形式，仅用于一些针对性的题目
注意事项：

字符串类似一个list，可以进行切片或使用s[::-1]的语法糖进行倒序，但不能s[i]="x"进行修改性赋值(请使用str.replace(...)或将其转为一个list)
isdigit()/isdecimal()/isnumeric()的区别使用场景为：
True	False	Error
isdigit	Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字	汉字数字	/
isdecimal	Unicode数字，，全角数字（双字节）	罗马数字，汉字数字	/
isnumeric	Unicode数字，全角数字（双字节），罗马数字，汉字数字	/	byte数字（单字节）

18. base64
    此模块提供了将二进制数据编码为可打印的 ASCII 字符以及将这些编码解码回二进制数据的函数，在某些数据分析题中很有用，但比较冷门，偶尔会遇到，如果掌握了可以节省大量的时间。

19. difflib
    此模块提供用于比较序列的类和函数，在算法题中属于冷门模块，在一些用于比较字符串差异的题目中可以进行使用，例如比较 两个字符串序列的前后差异：

c = difflib.ndiff("abcd", "abde")
for i in c:
    print(i)
1
2
3
TLE敏感操作
上文中提到了部分敏感操作，接下来继续总结一些：

x in obj要比obj.find(x)效率高，如str或list查找时。
对list进行扩增，以下三种方式的效率依次增高：for _ in range(j): li.append(x)<li[i:i+j] = [x]*j<li += [x]*j。
del x要比list.pop(index_x)效率高。
list.reverse()要比list[::-1]效率高。
[[0 for i in range(1000)] for j in range(1000)]要比[[0] * 1000 for j in range(1000)]效率高，但不推荐直接开一个特别大的数组，该操作本身非常耗时间。
li += [1, 2, 3]要比li.extend([1, 2, 3])效率高，但在扩增的数据量较少时，候没有绝对优势。
s.remove(x)要比s.pop(s.index(x))或del s[s.index(1)]有性能优势，如果非必要，请直接移除。相对的，还有以下性能比较：if x in s: s.remove(x)>del s[s.index(x)]>s.pop(s.index(x))；总而言之，若对索引不感兴趣，尽量用in关键字做包含性查询、用del关键字移除对象。
————————————————
版权声明：本文为CSDN博主「身披白袍」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Shenpibaipao/article/details/105873407
